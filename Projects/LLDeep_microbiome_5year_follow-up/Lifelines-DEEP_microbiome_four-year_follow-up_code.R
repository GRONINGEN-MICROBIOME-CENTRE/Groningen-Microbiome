####main codes for Lifelines-DEEP microbiome four-year follow-up study
###for questions, please contact LianminChen (lianminchen@yeah.net)

###############################################part 1 metagenomic raw data processing###################################################
###1.1 microbial taxonomy and pathway abundance were generated by using MetaPhlAn2.0 and HUMAnN2.0, pipeline available via: https://github.com/GRONINGEN-MICROBIOME-CENTRE/Groningen-Microbiome/blob/master/Scripts/Metagenomics_pipeline_v1.md
###1.2 microbial antibiotic resistance and virulence gene abundance were generated by using ShortBRED, pipeline available via: https://huttenhower.sph.harvard.edu/shortbred
###1.3 microbial strain SNP haplotype profiles in different species were generated by using StrainPhlAn, pipeline available via: https://github.com/GRONINGEN-MICROBIOME-CENTRE/Groningen-Microbiome/blob/master/Scripts/StrainPhlAn_analysis_pipeline.sh
###1.4 microbial strain structural variants (SVs) in different species were generated by using SGVFinder, pipeline available via: https://github.com/GRONINGEN-MICROBIOME-CENTRE/Groningen-Microbiome/blob/master/Scripts/SV_pipeline/Structural_variation_calling_for_metagenomic_data.md


############################################################part 2 statistics#############################################################
###2.1 differential microbial abundance (1000x permutation based paired wilcox.test)
#input 'data' is a matrix with paired sample id as rownames while microbial features as column names
per_wilcox_intra_test=function(data){
  base=data[grep("_F",row.names(data),invert = T),]
  fup=data[grep("_F",row.names(data),invert = F),]
  row.names(fup)=gsub("_F","",row.names(fup))
  fup=fup[row.names(base),]
  #real test
  result=data.frame(matrix(NA,nrow = ncol(data),ncol = 6))
  colnames(result)=c("microbiome","base_mean","fup_mean","delta_mean","wilcox_p","FDR")
  row.names(result)=colnames(data)
  for(i in 1:ncol(base)){
    result[i,1]=colnames(base)[i]
    result[i,2]=mean(base[,i],na.rm = T)
    result[i,3]=mean(fup[,i],na.rm = T)
    result[i,4]=mean(fup[,i]-base[,i],na.rm = T)
    try(result[i,5]<-wilcox.test(base[,i],fup[,i],paired = T)$p.value,silent = T)
  }
  #1000 permutation test
  per_p=matrix(NA,nrow = ncol(data),ncol = 1000)
  colnames(per_p)=paste("per",1:1000,sep = "_")
  row.names(per_p)=colnames(data)
  set.seed(666)
  for(i in 1:1000){
    permutation=sample(c(rep(1,169),rep(2,169)),338)
    print(i)
    base_per=rbind(base[which(permutation==1),],fup[which(permutation==2),])
    fup_per=rbind(base[which(permutation==2),],fup[which(permutation==1),]) 
    base_per=base_per[row.names(fup_per),]
    for(j in 1:ncol(base_per)){
      try(per_p[j,i]<-wilcox.test(base_per[,j],fup_per[,j],paired = T)$p.value,silent = T)
    }
  }
  #calculate permutational FDR
  result=result[order(result$wilcox_p,decreasing = F),]
  for(i in 1:nrow(result)){
    result$FDR[i]=(length(which(per_p<=result$wilcox_p[i]))/1000)/i
  }
  return(result)
}

###2.2 microbial fingerprint
##2.2.1 classification accurracy of classifier (distance matrix based apparoch)
#input 'distance' is a distance matrix
classification_rate=function(distance){
  diag(distance)=NA
  sample=intersect(gsub("_F","",row.names(distance)[grep("_F",row.names(distance))]),row.names(distance)[grep("_F",row.names(distance),invert = T)])
  distance=distance[c(sample,paste(sample,"_F",sep = "")),c(sample,paste(sample,"_F",sep = ""))]
  result=NULL
  if(length(sample)>0){
    for(k in 1:length(sample)){
      dist=distance[grep(sample[k],row.names(distance)),]
      intra=dist[,grep(sample[k],colnames(distance))][1,2]
      inter=as.vector(as.matrix(dist[,grep(sample[k],colnames(distance),invert = T)]))
      if(is.na(intra)==F){
        result=c(result,  1-length(which(inter<intra)))
      }
    }
    return(c(length(result),round(length(which(result==1))/length(result)*100,digits = 2)))
  }else{
    return(c(0,0))
  }
}
##2.2.2 multiple distance matrixes normalization
#input 'x' is a list of distance matrixes
dismat_normalization=function(x){
  for(i in 1:length(x)){
    x[[i]]=x[[i]]/max(x[[i]],na.rm = T)
  }
  return(x)
}
##2.2.3 multiple distance matrixes combination
#input 'x' and 'y' are distance matrixes that need to be combined
dismat_combin=function(x,y){
  data_combin=c(dismat_normalization(x), dismat_normalization(y))
  tmp=as.matrix(do.call(cbind, data_combin))
  tmp=array(tmp, dim=c(dim(data_combin[[1]]), length(data_combin)))
  tmp=colMeans(aperm(tmp, c(3, 1, 2)), na.rm = TRUE)
  row.names(tmp)=row.names(data_combin[[1]])
  colnames(tmp)=colnames(data_combin[[1]])
  tmp[is.nan(as.matrix(tmp))]=NA
  return(list(data.frame(tmp)))
}

###2.3 microbial associations to phenotypes and metabolites
##2.3.1 joint association: continous y ~ all x
#input 'data' is a data.frame with 'microbe'(e.g., abundance of a species), 'metabolites', 'pheno'(e.g., glucose levels),'age', 'sex', 'time'(i.e., baseline or follow-up) and 'id'(e.g., sample id)
library(lme4)
library(lmerTest)
association=summary(lmer(y~x+age+sex+(1|time)+(1|id),data))
##2.3.2 joint association: binary y ~ all x
#input 'data' is a data.frame with 'microbe'(e.g., abundance of a species), 'metabolites', 'pheno'(e.g., glucose levels),'age', 'sex', 'time'(i.e., baseline or follow-up) and 'id'(e.g., sample id)
library(sjstats)
library(lme4)
association=summary(glmer(y~x+age+sex+(1|time)+(1|id),data,family = binomial))$coefficients
##2.3.3 delta association: continous y ~ all x
#input 'data' is a data.frame with 'microbe'(e.g., delta abundance of a species), 'metabolites', 'pheno'(e.g., delta glucose levels),'age' and 'sex'
association=summary(lm(y~x+age+sex,data))
##2.3.4 delta association: binary y ~ all x
#input 'data' is a data.frame with 'microbe'(e.g., delta abundance of a species), 'metabolites', 'pheno'(e.g., delta glucose levels),'age' and 'sex'
association=summary(glm(y~x+age+sex,family=binomial(link='logit'),data))

###2.4 mediation analysis: microbial impacts on host phenotypes through metabolites
library(lme4)
library(mediation)
model.m=lmer(meta~microbe+age+sex+(1|time),data)
model.y=lmer(pheno~microbe+meta+age+sex+(1|time),data)
summary=summary(mediate(model.m ,model.y,treat = "microbe", mediator = "meta",boot = F,sims = 1000))
